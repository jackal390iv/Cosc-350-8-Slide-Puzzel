
import java.util.ArrayList;
import java.util.Scanner;

public class Puzzel {

    int childrens = 0;
    ArrayList<Node> theTree = new ArrayList<Node>();
    String base = "";
    char v1 = '1';
    char v2 = '2';
    char v3 = '3';
    char v4 = '4';
    char v5 = '5';
    char v6 = '6';
    char v7 = '7';
    char v8 = '8';
    char v_ = '_';
    Node startState = new Node(v5, v8, v6, v7, v_, v3, v2, v4, v1, null, 0, base, 0);
    Node endState = new Node(v1, v2, v3, v4, v5, v6, v7, v8, v_, null, 0, base, 0);

    public Puzzel() {
    }

    /**
     * asks user for a start state and an end state and creates those nodes
     */
    public void startEndState() {

        boolean valid = false;
        Scanner input = new Scanner(System.in);
        String state;
        System.out.println("Welcome, please enter a combination of the following characters as a start state for your puzzel;"
                + "\n"
                + "1,2,3,4,5,6,7,8, and _ (as your blank space): ");
        do {
            state = input.nextLine();
            state.replaceAll(",", "");
            state.replaceAll(" ", "");
            state.toLowerCase();

            valid = validate(state);

            if (valid == false) {
                System.out.println("I am sorry, but the start state you have entered is invalid, please try again: ");
            }

        } while (valid == false);


        Node temp1 = new Node(state.charAt(0), state.charAt(1),
                state.charAt(2), state.charAt(3), state.charAt(4),
                state.charAt(5), state.charAt(6), state.charAt(7),
                state.charAt(8), null, 0, base, 0);

        startState = temp1;

        //startState.printNode();

        valid = false;
        System.out.println("Thank you, now please enter an end state for your puzzel;"
                + "\n"
                + "using any combination of the the characters you used for your start state: ");
        do {
            state = input.nextLine();
            state.replaceAll(",", "");
            state.replaceAll(" ", "");
            state.toLowerCase();

            valid = validate(state);

            if (valid == false) {
                System.out.println("I am sorry, but the end state you have entered is invalid, please try again: ");
            }

        } while (valid = false);

        Node temp2 = new Node(state.charAt(0), state.charAt(1),
                state.charAt(2), state.charAt(3), state.charAt(4),
                state.charAt(5), state.charAt(6), state.charAt(7),
                state.charAt(8), null, 0, base, 0);
        endState = temp2;

        //endState.printNode();

        System.out.println("Thank you.");

        solver(startState, startState.getblankLoc());

    }

    /**
     * checks to see if user input is valid
     * @param state
     * @return 
     */
    private boolean validate(String state) {

        boolean valid = false;
        if (state.length() == 9) {
            if (((state.indexOf("1")) != -1) && ((state.indexOf("2")) != -1)
                    && ((state.indexOf("3")) != -1)
                    && ((state.indexOf("4")) != -1)
                    && ((state.indexOf("5")) != -1)
                    && ((state.indexOf("6")) != -1)
                    && ((state.indexOf("7")) != -1)
                    && ((state.indexOf("8")) != -1)
                    && ((state.indexOf("_")) != -1)) {
                valid = true;
            }
        }
        return valid;
    }

    /**
     * checks to see if the current node is equivalent to the end state that the user specified
     * @param currentState
     * @return 
     */
    public boolean endChecker(Node currentState) {
        boolean checker = false;
        if ((currentState.state[0][0] != endState.state[0][0]) || (currentState.state[0][1] != endState.state[0][1]) || (currentState.state[0][2] != endState.state[0][2])
                || (currentState.state[1][0] != endState.state[1][0]) || (currentState.state[1][1] != endState.state[1][1]) || (currentState.state[1][2] != endState.state[1][2])
                || (currentState.state[2][0] != endState.state[2][0]) || (currentState.state[2][1] != endState.state[2][1]) || (currentState.state[2][2] != endState.state[2][2])) {
            checker = true;
        }
        return checker;
    }

    /**
     * checks to see if the current node is equivalent to the start state that the user specified 
     * @param currentState 
     */
    public void startChecker(Node currentState) {
        currentState.printNode();
        if ((currentState.state[0][0] != startState.state[0][0]) || (currentState.state[0][1] != startState.state[0][1]) || (currentState.state[0][2] != startState.state[0][2])
                || (currentState.state[1][0] != startState.state[1][0]) || (currentState.state[1][1] != startState.state[1][1]) || (currentState.state[1][2] != startState.state[1][2])
                || (currentState.state[2][0] != startState.state[2][0]) || (currentState.state[2][1] != startState.state[2][1]) || (currentState.state[2][2] != startState.state[2][2])) {
            startChecker(currentState.getParent());
        }
    }

    /**
     * a tester method I used for short hand testing
     */
    public void testing() {

        solver(startState, startState.getblankLoc());
    }

    public void solver(Node currentState, int blank) {

        System.out.println("NEW LOOP: ");
        currentState.printNode();

        if (endChecker(currentState) == true) {
            Node temp = new Node(currentState.state[0][0], currentState.state[0][1],
                    currentState.state[0][2], currentState.state[1][0], currentState.state[1][1],
                    currentState.state[1][2], currentState.state[2][0], currentState.state[2][1],
                    currentState.state[2][2], currentState, currentState.getDepth() + 1, base, 0);

            if ((currentState.getChildren() == 2) && (((currentState.theUpEX() == false) && (currentState.theDownEX() == true) && (currentState.theLeftEX() == true) && (currentState.theRightEX() == false))
                    || ((currentState.theUpEX() == false) && (currentState.theDownEX() == true) && (currentState.theLeftEX() == false) && (currentState.theRightEX() == true))
                    || ((currentState.theUpEX() == true) && (currentState.theDownEX() == false) && (currentState.theLeftEX() == true) && (currentState.theRightEX() == false))
                    || ((currentState.theUpEX() == true) && (currentState.theDownEX() == false) && (currentState.theLeftEX() == false) && (currentState.theRightEX() == true)))) {
                currentState.finishedWithKids();
                //System.out.println("2 children");

            } else if ((currentState.getChildren() == 3) && (((currentState.theUpEX() == false) && (currentState.theDownEX() == true) && (currentState.theLeftEX() == true) && (currentState.theRightEX() == true))
                    || ((currentState.theUpEX() == true) && (currentState.theDownEX() == false) && (currentState.theLeftEX() == true) && (currentState.theRightEX() == true))
                    || ((currentState.theUpEX() == true) && (currentState.theDownEX() == true) && (currentState.theLeftEX() == false) && (currentState.theRightEX() == true))
                    || ((currentState.theUpEX() == true) && (currentState.theDownEX() == true) && (currentState.theLeftEX() == true) && (currentState.theRightEX() == false)))) {
                currentState.finishedWithKids();
                //System.out.println("3 children");
            } else if ((currentState.getChildren() == 4) && (((currentState.theUpEX() == true) && (currentState.theDownEX() == true) && (currentState.theLeftEX() == true) && (currentState.theRightEX() == true)))) {
                currentState.finishedWithKids();
                //System.out.println("4 children");
                
            } else if ((currentState.theUpEX()) && (currentState.getChildren() == 0)) {
                int originalv = startState.getblankLoc();
                int modv = originalv % 10;
                int secondv = modv - 1;
                int firstv = ((originalv - modv) - 10) / 10;
                temp.setMove("U");
                temp.state[firstv][secondv] = currentState.state[firstv - 1][secondv];
                temp.state[firstv - 1][secondv] = v_;
                temp.childNumChange(currentState.getChildren() + 1);
                theTree.add(temp);
                currentState.addChild();
                temp.printNode();
                solver(currentState, currentState.getblankLoc());
            } else if ((currentState.theDownEX()) && ((currentState.getChildren() == 0)
                    || ((currentState.getChildren() == 1) && (!((theTree.get(theTree.size() - 1).getMove().endsWith("D")) && (theTree.get(theTree.size() - 1).getParent() == currentState)))))) {
                int originalv = startState.getblankLoc();
                int modv = originalv % 10;
                int secondv = modv - 1;
                int firstv = ((originalv - modv) - 10) / 10;
                temp.setMove("D");
                temp.state[firstv][secondv] = currentState.state[firstv + 1][secondv];
                temp.state[firstv + 1][secondv] = v_;
                temp.childNumChange(currentState.getChildren() + 1);
                theTree.add(temp);
                currentState.addChild();
                temp.printNode();
                solver(currentState, currentState.getblankLoc());
            } else if ((currentState.theLeftEX()) && ((currentState.getChildren() == 0)
                    || ((currentState.getChildren() == 1) && (!((theTree.get(theTree.size() - 1).getMove().endsWith("L")) && (theTree.get(theTree.size() - 1).getParent() == currentState))))
                    || ((currentState.getChildren() == 2) && (!((theTree.get(theTree.size() - 1).getMove().endsWith("L")) && (theTree.get(theTree.size() - 1).getParent() == currentState)))))) {
                int originalv = startState.getblankLoc();
                int modv = originalv % 10;
                int secondv = modv - 1;
                int firstv = ((originalv - modv) - 10) / 10;
                temp.setMove("L");
                temp.state[firstv][secondv] = currentState.state[firstv][secondv - 1];
                temp.state[firstv][secondv - 1] = v_;
                temp.childNumChange(currentState.getChildren() + 1);
                theTree.add(temp);
                currentState.addChild();
                temp.printNode();
                solver(currentState, currentState.getblankLoc());
            } else if ((currentState.theRightEX()) && ((currentState.getChildren() == 0)
                    || ((currentState.getChildren() == 1) && (!((theTree.get(theTree.size() - 1).getMove().endsWith("R")) && (theTree.get(theTree.size() - 1).getParent() == currentState))))
                    || ((currentState.getChildren() == 2) && (!((theTree.get(theTree.size() - 1).getMove().endsWith("R")) && (theTree.get(theTree.size() - 1).getParent() == currentState))))
                    || ((currentState.getChildren() == 3) && (!((theTree.get(theTree.size() - 1).getMove().endsWith("R")) && (theTree.get(theTree.size() - 1).getParent() == currentState)))))) {
                int originalv = startState.getblankLoc();
                int modv = originalv % 10;
                int secondv = modv - 1;
                int firstv = ((originalv - modv) - 10) / 10;
                temp.setMove("R");
                temp.state[firstv][secondv] = currentState.state[firstv][secondv + 1];
                temp.state[firstv][secondv + 1] = v_;
                temp.childNumChange(currentState.getChildren() + 1);
                theTree.add(temp);
                currentState.addChild();
                temp.printNode();
                solver(currentState, currentState.getblankLoc());
            } else {
                System.out.println("NOPE$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
            }

        } else {

            //endGame(currentState);
            System.out.println("Right%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
            currentState.printNode();
            endState.printNode();

        }
    }

    public void endGame(Node currentState) {
        System.out.println("How The Puzzel can be solved in the fewest moves, from solution to starting point: ");
        startChecker(currentState);
        System.out.println("However Walking through our search varbosly we get: ");
        do {
            theTree.remove(0).printNode();
        } while (!(theTree.isEmpty()));
    }
}
